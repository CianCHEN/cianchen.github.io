{"meta":{"title":"CianCHEN","subtitle":"分享我所知","description":"90h","author":"Cian","url":"http://192.168.36.183:6888"},"pages":[{"title":"tags","date":"2018-12-23T07:07:21.000Z","updated":"2018-12-23T07:08:34.341Z","comments":true,"path":"tags/index.html","permalink":"http://192.168.36.183:6888/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-12-23T07:07:35.000Z","updated":"2018-12-23T07:09:11.193Z","comments":true,"path":"categories/index.html","permalink":"http://192.168.36.183:6888/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2018-12-23T07:20:44.000Z","updated":"2018-12-23T07:21:13.987Z","comments":true,"path":"about/index.html","permalink":"http://192.168.36.183:6888/about/index.html","excerpt":"","text":"一个测试博客的网站!"}],"posts":[{"title":"Zabbix LLD Discovery - zabbix监控之低等级发现","slug":"Zabbix-LLD-Discovery-zabbix监控之低等级发现","date":"2018-12-21T07:12:03.000Z","updated":"2018-12-24T03:25:46.199Z","comments":true,"path":"2018/12/21/Zabbix-LLD-Discovery-zabbix监控之低等级发现/","link":"","permalink":"http://192.168.36.183:6888/2018/12/21/Zabbix-LLD-Discovery-zabbix监控之低等级发现/","excerpt":"1.zabbix 的Regular expressions以下是一个zabbix文件系统自动发现的正则表达式，匹配到的话返回true：下面看一下文件系统自动发现的具体配置：在zabbix server通过zabbix_get获取一下文件系统发现的全部key：","text":"1.zabbix 的Regular expressions以下是一个zabbix文件系统自动发现的正则表达式，匹配到的话返回true：下面看一下文件系统自动发现的具体配置：在zabbix server通过zabbix_get获取一下文件系统发现的全部key：可以观察到，这里匹配{ #FSTYPE }的这个key，必须要符合上述正则表达式(返回True)才会返回，这个是zabbix自带的自动发现。再说说这个Filters的作用：实际上就是一个限制作用，只有符合我们自定义的规则，才会返回到zabbix的监控项，否则就不返回，这个看个人具体需求，适合一些已知的监控项，比如文件系统，网卡类型等。如果是不可控的可变类型，建议不要使用，会导致匹配失败而不能发现监控项。 2.监控实例单监控key实例1 监控mysql是否在线新建监控模板通常我的做法是新加一个lld规则，新建一个模板，填上模板名称即可 新建应用(aapplication)我这里把下一个实例的应用也同时创建了 添加监控脚本这一步是重点，通过自定义的脚本来为zabbix添加自定义key脚本输出必须为标准的json格式，至于用py 还是 shell自己选择，我是觉得系统数据获取还是shell比较方便修改zabbix_agentd.conf重启zabbix_agentd 就可以获取对应添加的key了，下面测试一下mysql.alived 就是添加的自定义key，可以正常返回获取对应{ #MYSQL_PORT } 端口的值：zabbix_get -s 192.168.236.32 -k &quot;mysql.alive[5500]&quot;以上测试通过之后可以进行下一步，这里注意脚本的权限，zabbix用户务必具有执行权限。 配置zabbix自动发现在zabbix面板新建两个discovery rules 配置discovery rule，这里Filters暂时不使用 为模板添加items 配置items 创建报警触发器 配置触发器我这里是正常返会1，异常返回0。当最后一次的值小于1时触发告警，告警级别为Disaster。 创建监控图表 配置监控图表以上就完成一个lld 自动发现模板的配置了。 监控测试进入到套用此模板的服务器，查看自动发现item是否已经正常加入监控。我们过滤一下mysql_alived这个application，可以看到监控项正常加入 测试告警可以关闭监控mysql进行。实例2 监控mysql主从(一从多主)关系是否正常参照2.1的配置就行了，就是修改一下key的名称即可。多监控key实例1 监控mysql主从(一从多主)延时监控脚本返回这个的步骤其实跟上边也是差不多的，先来看看监控返回格式这里其实就跟一开始我们分析的文件系统自动返现那里是类似的。跟上例子不一样的是，这里使用了两个json key作为一个分组，分别是{ #MYSQL_PORT } `{ #CHANNEL_NAME },我们现在要实现的是监控这些端口下所有channel的mysql主从同步的 Second_behind_master参数，所以我们必须先得到所有的mysql port 和 每个port 下对应的channel名称才能得到Second_behind_master的值。 这里mysql.behind 也是自定义的监控key，在zabbix_agentd.conf进行自定义添加即可。 配置regular expression新建一个regular expression，这里用途是匹配一从多主的channel_name,等下会用到 配置zabbix 自动发现新建一个模板，新建application，新建discovery rule这里filters使用上边刚刚添加的regular expression新建items这里{ #MYSQL_PORT } 和 { #CHANNEL_NAME } 的使用其实就很明确了，你得事先让zabbix知道他们分别代指什么东西，之后zabbix就能将他们作为数据参数来使用了，这就是为什么一开始就要先获取到这两个key的全部数据。 接下来添加触发器和添加图标的操作是一样的：下面是图表添加的范例 监控测试进入到套用模板的机器，过滤对应的application","categories":[{"name":"Zabbix 监控","slug":"Zabbix-监控","permalink":"http://192.168.36.183:6888/categories/Zabbix-监控/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://192.168.36.183:6888/tags/hexo/"},{"name":"zabbix","slug":"zabbix","permalink":"http://192.168.36.183:6888/tags/zabbix/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-12-21T05:47:07.153Z","updated":"2018-12-21T05:47:07.153Z","comments":true,"path":"2018/12/21/hello-world/","link":"","permalink":"http://192.168.36.183:6888/2018/12/21/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}